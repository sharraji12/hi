<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KVS workspace - Advanced MCQ Extractor and Solver (Firebase Full Edition with Chat)</title>
    <style>
        :root {
            --bg-color: #f4f4f4;
            --text-color: #333;
            --container-bg: #fff;
            --button-bg: #3498db;
            --button-hover: #2980b9;
            --code-bg: #f8f8f8;
            --border-color: #ddd;
            --table-header-bg: #f2f2f2;
            --sidebar-bg: #2c3e50;
            --sidebar-text: #ecf0f1;
        }

        [data-theme="dark"] {
            --bg-color: #2c3e50;
            --text-color: #ecf0f1;
            --container-bg: #34495e;
            --button-bg: #2980b9;
            --button-hover: #3498db;
            --code-bg: #2c3e50;
            --border-color: #7f8c8d;
            --table-header-bg: #2c3e50;
            --sidebar-bg: #1a252f;
            --sidebar-text: #bdc3c7;
        }

        [data-theme="blue"] {
            --bg-color: #e6f3ff;
            --text-color: #003366;
            --container-bg: #ffffff;
            --button-bg: #007bff;
            --button-hover: #0056b3;
            --code-bg: #f0f8ff;
            --border-color: #b3d9ff;
            --table-header-bg: #cce5ff;
            --sidebar-bg: #003366;
            --sidebar-text: #ffffff;
        }

        [data-theme="green"] {
            --bg-color: #e8f5e9;
            --text-color: #1b5e20;
            --container-bg: #ffffff;
            --button-bg: #4caf50;
            --button-hover: #45a049;
            --code-bg: #f1f8e9;
            --border-color: #c8e6c9;
            --table-header-bg: #a5d6a7;
            --sidebar-bg: #1b5e20;
            --sidebar-text: #ffffff;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            transition: background-color 0.3s ease;
        }

        .container {
            display: flex;
            min-height: 100vh;
        }

        #sidebar {
            width: 250px;
            background-color: var(--sidebar-bg);
            color: var(--sidebar-text);
            padding: 20px;
            overflow-y: auto;
            transition: left 0.3s ease;
        }

        #main-content {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            transition: margin-left 0.3s ease;
        }

        h1, h2 {
            color: var(--text-color);
            text-align: center;
        }

        button, .file-input-label {
            background-color: var(--button-bg);
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin: 5px;
            transition: background-color 0.3s, transform 0.1s;
            font-size: 16px;
            font-weight: 500;
        }

        button:hover, .file-input-label:hover {
            background-color: var(--button-hover);
            transform: translateY(-2px);
        }

        button:active, .file-input-label:active {
            transform: translateY(0);
        }

        input[type="text"], input[type="password"], input[type="email"], select {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 16px;
        }

        #imageGrid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 30px;
        }

        .image-container {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        #imageGrid img {
            width: 100%;
            height: auto;
            display: block;
        }

        .image-controls {
            position: absolute;
            top: 5px;
            right: 5px;
            display: flex;
            gap: 5px;
        }

        .image-control-btn {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .image-control-btn:hover {
            background-color: rgba(0, 0, 0, 0.7);
        }

        .code-block {
            background-color: var(--code-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-top: 30px;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Courier New', Courier, monospace;
            position: relative;
            font-size: 14px;
            line-height: 1.6;
        }

        .copy-button, .delete-button, .edit-button, .verify-button {
            position: absolute;
            top: 10px;
            background-color: rgba(39, 174, 96, 0.8);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .copy-button { right: 10px; }
        .delete-button { right: 70px; background-color: rgba(231, 76, 60, 0.8); }
        .edit-button { right: 140px; background-color: rgba(243, 156, 18, 0.8); }
        .verify-button { right: 210px; background-color: rgba(52, 152, 219, 0.8); }

        .copy-button:hover { background-color: rgba(46, 204, 113, 0.9); }
        .delete-button:hover { background-color: rgba(192, 57, 43, 0.9); }
        .edit-button:hover { background-color: rgba(211, 84, 0, 0.9); }
        .verify-button:hover { background-color: rgba(41, 128, 185, 0.9); }

        #promptBox {
            position: fixed;
            bottom: 0;
            left: 250px;
            right: 0;
            background-color: var(--container-bg);
            padding: 15px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
        }

        #promptInput {
            flex-grow: 1;
            margin-right: 10px;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 16px;
        }

        #progressBar {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            margin-top: 20px;
            overflow: hidden;
        }

        #progressBarFill {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.5s ease-in-out;
        }

        #progressText, #timerDisplay {
            text-align: center;
            font-size: 18px;
            margin-top: 10px;
            font-weight: bold;
        }

        .chat-session {
            padding: 10px;
            margin-bottom: 10px;
            background-color: var(--container-bg);
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-session:hover {
            background-color: var(--button-hover);
        }

        .active-chat {
            background-color: var(--button-bg);
            color: white;
        }

        #themeToggle, #sidebarToggle, #newChatBtn {
            position: fixed;
            z-index: 1001;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        #themeToggle { top: 20px; right: 20px; }
        #sidebarToggle { top: 20px; left: 20px; }
        #newChatBtn { top: 70px; left: 20px; }

        @media (max-width: 768px) {
            .container { flex-direction: column; }
            #sidebar { width: 100%; height: auto; }
            #main-content { margin-left: 0; }
            #promptBox { left: 0; }
        }
    </style>
</head>
<body>
    <button id="themeToggle">🌓</button>
    <button id="sidebarToggle">☰</button>
    <button id="newChatBtn">+</button>
    <div class="container">
        <div id="sidebar">
            <h2>Chat Sessions</h2>
            <div id="chatList"></div>
        </div>
        <div id="main-content">
            <h1>KVS workspace - Advanced MCQ Extractor and Solver</h1>
            
            <div id="authContainer">
                <div id="loginForm">
                    <h2>Login</h2>
                    <input type="email" id="loginEmail" placeholder="Email">
                    <input type="password" id="loginPassword" placeholder="Password">
                    <button onclick="login()">Login</button>
                    <button onclick="loginWithGoogle()">Login with Google</button>
                </div>
                <div id="signupForm">
                    <h2>Sign Up</h2>
                    <input type="email" id="signupEmail" placeholder="Email">
                    <input type="password" id="signupPassword" placeholder="Password">
                    <input type="tel" id="phoneNumber" placeholder="Phone Number (for OTP)">
                    <button onclick="signup()">Sign Up</button>
                </div>
                <div id="otpForm" style="display: none;">
                    <h2>Enter OTP</h2>
                    <input type="text" id="otpInput" placeholder="Enter OTP">
                    <button onclick="verifyOTP()">Verify OTP</button>
                </div>
            </div>

            <div id="userInfo" style="display: none;">
                <p>Logged in as: <span id="userEmail"></span></p>
                <button onclick="logout()">Logout</button>
            </div>

            <div id="appContent" style="display: none;">
                <input type="text" id="apiKey" placeholder="Enter your Gemini API Key">
                <select id="modelSelect">
                    <option value="gemini-1.5-pro-latest">Gemini 1.5 Pro</option>
                    <option value="gemini-1.0-pro-latest">Gemini 1.0 Pro</option>
                </select>
                <div>
                    <label for="pdfInput" class="file-input-label">
                        Upload PDF
                        <input type="file" id="pdfInput" accept=".pdf">
                    </label>
                    <label for="imageInput" class="file-input-label">
                        Add Images
                        <input type="file" id="imageInput" accept="image/*" multiple>
                    </label>
                    <button onclick="processMCQs(false)">Extract MCQs Only</button>
                    <button onclick="processMCQs(true)">Extract and Solve MCQs</button>
                    <button onclick="orderMCQs()">Order MCQs Numerically</button>
                    <button onclick="copyAllResults()">Copy All Results</button>
                    <button onclick="recheckSolutions()">Recheck Solutions</button>
                </div>
                <div id="imageGrid"></div>
                <div id="progressBar">
                    <div id="progressBarFill"></div>
                </div>
                <div id="progressText"></div>
                <div id="timerDisplay"></div>
                <div id="resultsContainer"></div>
            </div>
        </div>
    </div>
    <div id="promptBox">
        <input type="text" id="promptInput" placeholder="Enter your prompt for modifying MCQs...">
        <button onclick="processPrompt()">Process</button>
    </div>
    <audio id="alarmSound" src="https://www.soundjay.com/buttons/button-3.mp3"></audio>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.9.359/pdf.min.js"></script>

    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBSbpgNHrllE3LqE7AqvvJSFxOb3uHBWRs",
            authDomain: "corded-academy-404101.firebaseapp.com",
            projectId: "corded-academy-404101",
            storageBucket: "corded-academy-404101.appspot.com",
            messagingSenderId: "639823673602",
            appId: "1:639823673602:web:f97ee37fbd38ca0bca6a1b",
            measurementId: "G-8PBCR51KW5"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();

        let currentUser = null;
        let currentChatSession = null;
        let chatSessions = [];
        let images = [];
        let allResults = [];
        let promptImages = [];
        let processingQueue = [];
        let isProcessing = false;
        const RATE_LIMIT_DELAY = 1000;
        const IMAGE_PROCESSING_DELAY = 500;
        let startTime;
        let timerInterval;

        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.9.359/pdf.worker.min.js';

        // Authentication functions
        function signup() {
            const email = document.getElementById('signupEmail').value;
            const password = document.getElementById('signupPassword').value;
            const phoneNumber = document.getElementById('phoneNumber').value;

            if (!phoneNumber.startsWith('+91')) {
                alert('OTP verification is only available for Indian phone numbers (+91).');
                return;
            }

            auth.createUserWithEmailAndPassword(email, password)
                .then((userCredential) => {
                    console.log('User signed up');
                    currentUser = userCredential.user;
                    sendOTP(phoneNumber);
                })
                .catch((error) => {
                    console.error('Error signing up:', error);
                    alert('Sign up failed: ' + error.message);
                });
        }

        function sendOTP(phoneNumber) {
            // In a real implementation, you would integrate with a service to send OTP
            // For this example, we'll simulate it
            alert('OTP sent to ' + phoneNumber);
            document.getElementById('otpForm').style.display = 'block';
        }

        function verifyOTP() {
            const otp = document.getElementById('otpInput').value;
            // In a real implementation, you would verify the OTP with your service
            // For this example, we'll simulate it
            if (otp === '123456') { // Example OTP
                showUserInfo(currentUser);
                createNewChatSession();
            } else {
                alert('Invalid OTP');
            }
        }

        function login() {
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            auth.signInWithEmailAndPassword(email, password)
                .then((userCredential) => {
                    console.log('User logged in');
                    currentUser = userCredential.user;
                    showUserInfo(currentUser);
                    loadChatSessions();
                })
                .catch((error) => {
                    console.error('Error logging in:', error);
                    alert('Login failed: ' + error.message);
                });
        }

        function loginWithGoogle() {
            const provider = new firebase.auth.GoogleAuthProvider();
            auth.signInWithPopup(provider)
                .then((result) => {
                    console.log('User logged in with Google');
                    currentUser = result.user;
                    showUserInfo(currentUser);
                    loadChatSessions();
                }).catch((error) => {
                    console.error('Error logging in with Google:', error);
                    alert('Google login failed: ' + error.message);
                });
        }

        function logout() {
            auth.signOut().then(() => {
                console.log('User signed out');
                currentUser = null;
                currentChatSession = null;
                chatSessions = [];
                showAuthForms();
            }).catch((error) => {
                console.error('Error signing out:', error);
            });
        }

        function showUserInfo(user) {
            document.getElementById('authContainer').style.display = 'none';
            document.getElementById('userInfo').style.display = 'block';
            document.getElementById('appContent').style.display = 'block';
            document.getElementById('userEmail').textContent = user.email;
        }

        function showAuthForms() {
            document.getElementById('authContainer').style.display = 'block';
            document.getElementById('userInfo').style.display = 'none';
            document.getElementById('appContent').style.display = 'none';
        }

        // Chat session functions
        function createNewChatSession() {
            const sessionName = prompt("Enter a name for the new chat session:", "New Chat");
            if (sessionName) {
                const newSession = {
                    name: sessionName,
                    userId: currentUser.uid,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                    content: []
                };

                db.collection("chatSessions").add(newSession)
                    .then((docRef) => {
                        console.log("New chat session created with ID: ", docRef.id);
                        loadChatSessions();
                    })
                    .catch((error) => {
                        console.error("Error creating new chat session: ", error);
                        alert("Failed to create new chat session. Please try again.");
                    });
            }
        }

        function loadChatSessions() {
            db.collection("chatSessions")
                .where("userId", "==", currentUser.uid)
                .orderBy("lastUpdated", "desc")
                .get()
                .then((querySnapshot) => {
                    chatSessions = [];
                    querySnapshot.forEach((doc) => {
                        chatSessions.push({ id: doc.id, ...doc.data() });
                    });
                    displayChatSessions();
                    if (chatSessions.length > 0) {
                        loadChatSession(chatSessions[0].id);
                    } else {
                        createNewChatSession();
                    }
                })
                .catch((error) => {
                    console.error("Error loading chat sessions: ", error);
                    alert("Failed to load chat sessions. Please try again.");
                });
        }

        function displayChatSessions() {
            const chatList = document.getElementById('chatList');
            chatList.innerHTML = '';
            chatSessions.forEach((session) => {
                const sessionElement = document.createElement('div');
                sessionElement.className = 'chat-session';
                sessionElement.textContent = session.name;
                sessionElement.onclick = () => loadChatSession(session.id);
                
                const editButton = document.createElement('button');
                editButton.textContent = '✏️';
                editButton.onclick = (e) => {
                    e.stopPropagation();
                    editChatSessionName(session.id);
                };
                sessionElement.appendChild(editButton);
                
                chatList.appendChild(sessionElement);
            });
        }

        function loadChatSession(sessionId) {
            currentChatSession = chatSessions.find(session => session.id === sessionId);
            if (currentChatSession) {
                document.querySelectorAll('.chat-session').forEach(el => el.classList.remove('active-chat'));
                document.querySelector(`.chat-session:nth-child(${chatSessions.indexOf(currentChatSession) + 1})`).classList.add('active-chat');
                displaySessionContent();
            }
        }

        function displaySessionContent() {
            images = [];
            allResults = [];
            const imageGrid = document.getElementById('imageGrid');
            const resultsContainer = document.getElementById('resultsContainer');
            imageGrid.innerHTML = '';
            resultsContainer.innerHTML = '';

            currentChatSession.content.forEach(item => {
                if (item.type === 'image') {
                    addImageToGrid(item.data, false);
                } else if (item.type === 'result') {
                    addResultToContainer(item.data);
                }
            });
        }

        function editChatSessionName(sessionId) {
            const session = chatSessions.find(s => s.id === sessionId);
            const newName = prompt("Enter new name for the chat session:", session.name);
            if (newName && newName !== session.name) {
                db.collection("chatSessions").doc(sessionId).update({ 
                    name: newName,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
                })
                .then(() => {
                    console.log("Chat session name updated successfully");
                    session.name = newName;
                    displayChatSessions();
                })
                .catch((error) => {
                    console.error("Error updating chat session name: ", error);
                    alert("Failed to update chat session name. Please try again.");
                });
            }
        }

        function saveToChatSession(content) {
            if (!currentChatSession) return;

            currentChatSession.content.push(content);
            db.collection("chatSessions").doc(currentChatSession.id).update({
                content: firebase.firestore.FieldValue.arrayUnion(content),
                lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
            }).catch(error => {
                console.error("Error saving to chat session: ", error);
                alert("Failed to save content to chat session. Please try again.");
            });
        }

        // Image processing functions
        async function convertPDFToImages(file) {
            const pdf = await pdfjsLib.getDocument(URL.createObjectURL(file)).promise;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                const page = await pdf.getPage(pageNum);
                const viewport = page.getViewport({ scale: 1.5 });
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                await page.render({ canvasContext: ctx, viewport }).promise;
                const imageUrl = canvas.toDataURL();
                addImageToGrid(imageUrl, true);
            }
        }

        function addImageToGrid(src, isNewImage = true) {
            const imageGrid = document.getElementById('imageGrid');
            const container = document.createElement('div');
            container.className = 'image-container';

            const img = document.createElement('img');
            img.src = src;
            img.onload = function() {
                if (isNewImage) {
                    const imageFile = dataURLtoFile(img.src, `image_${Date.now()}.png`);
                    images.push(imageFile);
                    saveToChatSession({ type: 'image', data: src });
                }
            }

            const removeButton = document.createElement('button');
            removeButton.className = 'image-control-btn';
            removeButton.textContent = '×';
            removeButton.onclick = function() {
                container.remove();
                images = images.filter(img => img.name !== container.dataset.filename);
                saveToChatSession({ type: 'remove_image', data: container.dataset.filename });
            };

            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'image-controls';
            controlsDiv.appendChild(removeButton);

            container.appendChild(img);
            container.appendChild(controlsDiv);
            imageGrid.appendChild(container);
        }

        function dataURLtoFile(dataurl, filename) {
            let arr = dataurl.split(','),
                mime = arr[0].match(/:(.*?);/)[1],
                bstr = atob(arr[1]), 
                n = bstr.length, 
                u8arr = new Uint8Array(n);
            while(n--){
                u8arr[n] = bstr.charCodeAt(n);
            }
            return new File([u8arr], filename, {type:mime});
        }

        // MCQ processing functions
        async function processMCQs(withSolution) {
            const apiKey = document.getElementById('apiKey').value;
            const modelName = document.getElementById('modelSelect').value;
            const resultsContainer = document.getElementById('resultsContainer');

            if (!apiKey) {
                alert('Please enter API key.');
                return;
            }

            if (images.length === 0) {
                alert('Please add at least one image.');
                return;
            }

            resultsContainer.innerHTML = "<div class='code-block'>Processing MCQs from images...</div>";
            allResults = [];

            processingQueue = [...images];
            isProcessing = true;
            startTimer();
            updateProgressBar(0, images.length);

            await processNextImage(apiKey, modelName, withSolution);
        }

        async function processNextImage(apiKey, modelName, withSolution) {
            if (processingQueue.length === 0) {
                isProcessing = false;
                updateProgressBar(images.length, images.length);
                displayResults();
                stopTimer();
                playAlarmSound();
                saveToChatSession({ type: 'results', data: allResults });
                return;
            }

            const image = processingQueue.shift();

            try {
                const imageData = await getBase64(image);
                const processedMCQ = await callGeminiAPI(apiKey, modelName, imageData, image.type, withSolution);
                allResults.push(processedMCQ);
                updateProgressBar(images.length - processingQueue.length, images.length);
            } catch (error) {
                console.error(`Error processing image:`, error);
                if (error.message.includes('Rate limit exceeded')) {
                    processingQueue.unshift(image);
                    await new Promise(resolve => setTimeout(resolve, RATE_LIMIT_DELAY));
                } else {
                    allResults.push(`Error processing image: ${error.message}`);
                }
            }

            await new Promise(resolve => setTimeout(resolve, IMAGE_PROCESSING_DELAY));
            await processNextImage(apiKey, modelName, withSolution);
        }

        function getBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = error => reject(error);
            });
        }

        async function callGeminiAPI(apiKey, modelName, imageData, mimeType, withSolution) {
            const prompt = `Analyze this image containing multiple-choice questions (MCQs). Extract the questions, options, and ${withSolution ? 'provide solutions' : 'do not provide solutions'}. Follow these rules:

            1. Format each MCQ ${withSolution ? 'and its solution ' : ''}as a separate block.
            2. Left-align all content within each block.
            3. Use numbers (1, 2, 3, 4) instead of letters for options.
            4. Preserve the original question numbers from the image.
            5. ${withSolution ? 'Provide the solution directly after the options within the same block.' : 'Do not provide solutions.'}
            6. Indicate the correct answer with a green checkmark (✅) next to the correct option.
            7. If there's a table in the question, format it using HTML table tags. Use the class "mcq-table" for the table element.
            8. Use this format for your output:

            [Original Question number]. [Question text]
            [HTML table, if present]
            1. [Option 1]
            2. [Option 2]
            3. [Option 3]
            4. [Option 4] ✅ (if this is the correct answer)
            ${withSolution ? 'Solution: [Detailed explanation of the solution with complete calculations, presented line by line for readability]' : ''}

            9. Do not use LaTeX formatting. Present all content in plain text.
            10. Use '^' for exponents instead of HTML superscript tags. For example, write 'x^2' instead of 'x<sup>2</sup>'.
            11. If you detect a diagram or complex image in the question, add the fire emoji (🔥) at the beginning of the question text.
            ${withSolution ? '12. Prioritize accuracy in all calculations and logic.' : ''}
            13. Separate each MCQ block with two blank lines.
            14. Do not include phrases like "Therefore, the correct answer is...".

            Your primary goal is to provide accurate, well-formatted MCQs${withSolution ? ' and solutions' : ''} based on the image content provided.`;

            const maxRetries = 5;
            const baseDelay = 1000; // 1 second

            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                parts: [
                                    { text: prompt },
                                    { inline_data: { mime_type: mimeType, data: imageData } }
                                ]
                            }],
                            generationConfig: {
                                temperature: 0.1,
                                topK: 40,
                                topP: 0.95,
                                maxOutputTokens: 8192,
                                stopSequences: []
                            }
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        if (response.status === 429) {
                            const delay = baseDelay * Math.pow(2, attempt);
                            console.log(`Rate limit exceeded. Retrying in ${delay}ms...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue;
                        }
                        throw new Error(`API error: ${response.status} - ${JSON.stringify(errorData)}`);
                    }

                    const data = await response.json();
                    return data.candidates[0].content.parts[0].text.trim();
                } catch (error) {
                    if (attempt === maxRetries - 1) {
                        throw error;
                    }
                }
            }
        }

        function displayResults() {
            const resultsContainer = document.getElementById('resultsContainer');
            resultsContainer.innerHTML = '';
            allResults.forEach((result, index) => {
                const codeBlock = document.createElement('div');
                codeBlock.className = 'code-block';
                codeBlock.innerHTML = `<div class="editable" contenteditable="true">${result}</div>`;
                
                const copyButton = document.createElement('button');
                copyButton.className = 'copy-button';
                copyButton.textContent = 'Copy';
                copyButton.onclick = () => copyToClipboard(result, copyButton);
                
                const deleteButton = document.createElement('button');
                deleteButton.className = 'delete-button';
                deleteButton.textContent = 'Delete';
                deleteButton.onclick = () => deleteResult(index);
                
                const editButton = document.createElement('button');
                editButton.className = 'edit-button';
                editButton.textContent = 'Save';
                editButton.onclick = () => saveEdit(index, codeBlock.querySelector('.editable'));
                
                const verifyButton = document.createElement('button');
                verifyButton.className = 'verify-button';
                verifyButton.textContent = 'Verify Solution';
                verifyButton.onclick = () => verifySolution(index);
                
                codeBlock.appendChild(copyButton);
                codeBlock.appendChild(deleteButton);
                codeBlock.appendChild(editButton);
                codeBlock.appendChild(verifyButton);
                resultsContainer.appendChild(codeBlock);
            });
        }

        function copyToClipboard(text, button) {
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            }, (err) => {
                console.error('Could not copy text: ', err);
                alert('Failed to copy text. Please try again.');
            });
        }

        function orderMCQs() {
            const orderedResults = allResults.flatMap(result => result.split('\n\n\n'))
                .filter(mcq => mcq.trim().match(/^\d+\./))
                .sort((a, b) => {
                    const numA = parseInt(a.match(/^(\d+)\./)[1]);
                    const numB = parseInt(b.match(/^(\d+)\./)[1]);
                    return numA - numB;
                });

            // Check for missing MCQs
            const numbers = orderedResults.map(mcq => parseInt(mcq.match(/^(\d+)\./)[1]));
            const maxNumber = Math.max(...numbers);
            for (let i = 1; i <= maxNumber; i++) {
                if (!numbers.includes(i)) {
                    console.warn(`MCQ number ${i} is missing`);
                }
            }

            allResults = [orderedResults.join('\n\n\n')];
            displayResults();
            saveToChatSession({ type: 'results', data: allResults });
        }

        function copyAllResults() {
            const allText = allResults.join('\n\n\n');
            copyToClipboard(allText, document.querySelector('.copy-button'));
        }

        function deleteResult(index) {
            allResults.splice(index, 1);
            displayResults();
            saveToChatSession({ type: 'results', data: allResults });
        }

        function saveEdit(index, editableDiv) {
            allResults[index] = editableDiv.innerText;
            displayResults();
            saveToChatSession({ type: 'results', data: allResults });
        }

        async function recheckSolutions() {
            const apiKey = document.getElementById('apiKey').value;
            const modelName = document.getElementById('modelSelect').value;

            if (!apiKey) {
                alert('Please enter API key.');
                return;
            }

            const reCheckedResults = [];
            for (let mcq of allResults.flatMap(result => result.split('\n\n\n'))) {
                try {
                    const recheckedMCQ = await callGeminiAPI(apiKey, modelName, mcq, 'text/plain', true);
                    reCheckedResults.push(recheckedMCQ);
                } catch (error) {
                    console.error(`Error rechecking MCQ:`, error);
                    reCheckedResults.push(`Error rechecking MCQ: ${error.message}`);
                }
                await new Promise(resolve => setTimeout(resolve, IMAGE_PROCESSING_DELAY));
            }

            allResults = [reCheckedResults.join('\n\n\n')];
            displayResults();
            saveToChatSession({ type: 'results', data: allResults });
        }

        async function verifySolution(index) {
            const apiKey = document.getElementById('apiKey').value;
            const modelName = document.getElementById('modelSelect').value;

            if (!apiKey) {
                alert('Please enter API key.');
                return;
            }

            const mcq = allResults[index];
            try {
                const verifiedMCQ = await callGeminiAPI(apiKey, modelName, mcq, 'text/plain', true);
                allResults[index] = verifiedMCQ;
                displayResults();
                saveToChatSession({ type: 'results', data: allResults });
            } catch (error) {
                console.error(`Error verifying solution:`, error);
                alert(`Error verifying solution: ${error.message}`);
            }
        }

        async function processPrompt() {
            const apiKey = document.getElementById('apiKey').value;
            const modelName = document.getElementById('modelSelect').value;
            const promptInput = document.getElementById('promptInput');

            if (!apiKey) {
                alert('Please enter API key.');
                return;
            }

            const userPrompt = promptInput.value;
            if (!userPrompt) {
                alert('Please enter a prompt.');
                return;
            }

            try {
                const currentMCQs = allResults.length > 0 ? allResults.join('\n\n') : "No MCQs extracted yet.";

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{
                            parts: [
                                { text: `Current MCQs:\n\n${currentMCQs}\n\nUser prompt: ${userPrompt}\n\nInstructions:
                1. Process the MCQs according to the user's prompt.
                2. Only modify the questions specified in the prompt.
                3. For each modified question, create a new entry without changing the original.
                4. Do not include phrases like "Therefore, the correct answer is...".
                5. Maintain the original formatting and structure of the MCQs.
                6. If no MCQs exist, generate new ones based on the prompt.
                7. Return only the new or modified MCQs, not the entire set.
                8. Provide complete calculations in solutions, formatted line by line for readability.
                9. Use '^' for exponents instead of HTML superscript tags. For example, write 'x^2' instead of 'x<sup>2</sup>'.
                10. If you detect a diagram or complex image in the question, add the fire emoji (🔥) at the beginning of the question text.` }
                            ]
                        }],
                        generationConfig: {
                            temperature: 0.7,
                            topK: 40,
                            topP: 0.95,
                            maxOutputTokens: 8192,
                            stopSequences: []
                        }
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API error: ${response.status} - ${JSON.stringify(errorData)}`);
                }

                const data = await response.json();
                const processedResult = data.candidates[0].content.parts[0].text.trim();
                allResults.push(processedResult);
                displayResults();
                promptInput.value = '';
                saveToChatSession({ type: 'results', data: allResults });
            } catch (error) {
                console.error('Error processing prompt:', error);
                alert(`Error processing prompt: ${error.message}`);
            }
        }

        function updateProgressBar(current, total) {
            const progressBar = document.getElementById('progressBarFill');
            const progressText = document.getElementById('progressText');
            const percentage = (current / total) * 100;
            progressBar.style.width = `${percentage}%`;
            progressText.textContent = `Processing: ${current} / ${total} images`;
        }

        function startTimer() {
            startTime = Date.now();
            updateTimer();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        function updateTimer() {
            const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            const hours = Math.floor(elapsedTime / 3600);
            const minutes = Math.floor((elapsedTime % 3600) / 60);
            const seconds = elapsedTime % 60;
            document.getElementById('timerDisplay').textContent = 
                `Time elapsed: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function playAlarmSound() {
            const alarmSound = document.getElementById('alarmSound');
            alarmSound.play();
        }

        // Event listeners
        document.getElementById('newChatBtn').addEventListener('click', createNewChatSession);
        document.getElementById('themeToggle').addEventListener('click', toggleTheme);
        document.getElementById('sidebarToggle').addEventListener('click', toggleSidebar);

        document.getElementById('pdfInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file && file.type === 'application/pdf') {
                convertPDFToImages(file);
            } else {
                alert('Please upload a PDF file.');
            }
        });

        document.getElementById('imageInput').addEventListener('change', function(e) {
            Array.from(e.target.files).forEach(file => {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => addImageToGrid(event.target.result);
                    reader.readAsDataURL(file);
                }
            });
        });

        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            let newTheme;
            switch (currentTheme) {
                case 'light':
                    newTheme = 'dark';
                    break;
                case 'dark':
                    newTheme = 'blue';
                    break;
                case 'blue':
                    newTheme = 'green';
                    break;
                default:
                    newTheme = 'light';
            }
            document.documentElement.setAttribute('data-theme', newTheme);
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.getElementById('main-content');
            sidebar.style.left = sidebar.style.left === '0px' ? '-250px' : '0px';
            mainContent.style.marginLeft = mainContent.style.marginLeft === '250px' ? '0px' : '250px';
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Check if user is already logged in
            auth.onAuthStateChanged((user) => {
                if (user) {
                    currentUser = user;
                    showUserInfo(user);
                    loadChatSessions();
                } else {
                    showAuthForms();
                }
            });

            // Set initial theme
            const prefersDarkScheme = window.matchMedia("(prefers-color-scheme: dark)");
            if (prefersDarkScheme.matches) {
                document.documentElement.setAttribute('data-theme', 'dark');
            } else {
                document.documentElement.setAttribute('data-theme', 'light');
            }
        });

        // Autosave when closing the browser or switching tabs
        window.addEventListener('beforeunload', function (e) {
            if (currentChatSession) {
                saveToChatSession({ type: 'autosave', data: { images, allResults } });
            }
        });

        // Drag and drop functionality for images
        document.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        document.addEventListener('drop', (e) => {
            e.preventDefault();
            handleFiles(e.dataTransfer.files);
        });

        function handleFiles(files) {
            Array.from(files).forEach(file => {
                if (file.type === 'application/pdf') {
                    convertPDFToImages(file);
                } else if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => addImageToGrid(event.target.result);
                    reader.readAsDataURL(file);
                }
            });
        }

        // Paste functionality for images
        document.addEventListener('paste', (e) => {
            const items = e.clipboardData.items;
            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    const blob = item.getAsFile();
                    const reader = new FileReader();
                    reader.onload = (event) => addImageToGrid(event.target.result);
                    reader.readAsDataURL(blob);
                }
            }
        });

        // Function to load the most recent chat when logging in
        function loadMostRecentChat() {
            if (!currentUser) return;

            db.collection("chatSessions")
                .where("userId", "==", currentUser.uid)
                .orderBy("lastUpdated", "desc")
                .limit(1)
                .get()
                .then((querySnapshot) => {
                    if (!querySnapshot.empty) {
                        loadChatSession(querySnapshot.docs[0].id);
                    } else {
                        createNewChatSession();
                    }
                })
                .catch((error) => {
                    console.error("Error loading most recent chat: ", error);
                    createNewChatSession();
                });
        }

        // Modify the showUserInfo function to load the most recent chat
        function showUserInfo(user) {
            document.getElementById('authContainer').style.display = 'none';
            document.getElementById('userInfo').style.display = 'block';
            document.getElementById('appContent').style.display = 'block';
            document.getElementById('userEmail').textContent = user.email;
            loadMostRecentChat();
        }

        // Function to handle real-time updates
        function setupRealtimeUpdates() {
            if (!currentUser) return;

            db.collection("chatSessions")
                .where("userId", "==", currentUser.uid)
                .onSnapshot((snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === "modified") {
                            const updatedSession = { id: change.doc.id, ...change.doc.data() };
                            const index = chatSessions.findIndex(session => session.id === updatedSession.id);
                            if (index !== -1) {
                                chatSessions[index] = updatedSession;
                                if (currentChatSession && currentChatSession.id === updatedSession.id) {
                                    currentChatSession = updatedSession;
                                    displaySessionContent();
                                }
                            }
                            displayChatSessions();
                        }
                    });
                }, (error) => {
                    console.error("Error setting up real-time updates: ", error);
                });
        }

        // Call setupRealtimeUpdates when user logs in
        auth.onAuthStateChanged((user) => {
            if (user) {
                currentUser = user;
                showUserInfo(user);
                loadChatSessions();
                setupRealtimeUpdates();
            } else {
                showAuthForms();
            }
        });

        // Function to export chat session
        function exportChatSession() {
            if (!currentChatSession) return;

            const exportData = JSON.stringify(currentChatSession, null, 2);
            const blob = new Blob([exportData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `chat_session_${currentChatSession.id}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Function to import chat session
        function importChatSession(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedSession = JSON.parse(e.target.result);
                    importedSession.userId = currentUser.uid;
                    importedSession.importedAt = firebase.firestore.FieldValue.serverTimestamp();
                    delete importedSession.id; // Remove the old id to create a new document

                    db.collection("chatSessions").add(importedSession)
                        .then((docRef) => {
                            console.log("Imported chat session with ID: ", docRef.id);
                            loadChatSessions();
                        })
                        .catch((error) => {
                            console.error("Error importing chat session: ", error);
                            alert("Failed to import chat session. Please try again.");
                        });
                } catch (error) {
                    console.error("Error parsing imported chat session: ", error);
                    alert("Invalid chat session file. Please try again.");
                }
            };
            reader.readAsText(file);
        }

        // Add event listener for import button
        document.getElementById('importChatBtn').addEventListener('click', function() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => importChatSession(e.target.files[0]);
            input.click();
        });

        // Add event listener for export button
        document.getElementById('exportChatBtn').addEventListener('click', exportChatSession);

        // Function to delete a chat session
        function deleteChatSession(sessionId) {
            if (confirm("Are you sure you want to delete this chat session? This action cannot be undone.")) {
                db.collection("chatSessions").doc(sessionId).delete()
                    .then(() => {
                        console.log("Chat session successfully deleted");
                        if (currentChatSession && currentChatSession.id === sessionId) {
                            currentChatSession = null;
                            loadMostRecentChat();
                        }
                        loadChatSessions();
                    })
                    .catch((error) => {
                        console.error("Error removing chat session: ", error);
                        alert("Failed to delete chat session. Please try again.");
                    });
            }
        }

        // Modify displayChatSessions to include delete button
        function displayChatSessions() {
            const chatList = document.getElementById('chatList');
            chatList.innerHTML = '';
            chatSessions.forEach((session) => {
                const sessionElement = document.createElement('div');
                sessionElement.className = 'chat-session';
                sessionElement.textContent = session.name;
                sessionElement.onclick = () => loadChatSession(session.id);
                
                const editButton = document.createElement('button');
                editButton.textContent = '✏️';
                editButton.onclick = (e) => {
                    e.stopPropagation();
                    editChatSessionName(session.id);
                };

                const deleteButton = document.createElement('button');
                deleteButton.textContent = '🗑️';
                deleteButton.onclick = (e) => {
                    e.stopPropagation();
                    deleteChatSession(session.id);
                };

                sessionElement.appendChild(editButton);
                sessionElement.appendChild(deleteButton);
                chatList.appendChild(sessionElement);
            });
        }
    </script>
</body>
</html>